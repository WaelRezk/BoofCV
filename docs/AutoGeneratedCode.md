# Automatically Generated Code in BoofCV

BoofCV uses different approaches to autogenerate code which has similar or identical algorithms across different
data structures. Examples include creating image convolution code for all images types, converting Float-64 into Float-32
code, and generating concurrent implementations. Some code is auto generated from existing Java files and as a result
the order that you generate the code matters.

Generating all the auto generated code can be done easily by invoking `./gradlew autogenerate` however that hides
significant complexity that needs to be handled as a developer. This document describes how the build system
works and how to add more auto generated code.

 * `boofcv/main/autocode` contains only code related to code generation and is where the gradle command "autogenerate" is defined
 * `boofcv/main/boofcv-types` Contains many data types but of interest here are data types used to specify image types for auto code generation
 * `sourceSet.noauto` Is a special sourceSet where no auto generated code is allowed. This is done to prevent a cyclical dependency form forming
 * `sourceSet.generate` Where individual sub-projects can put their auto generated code.
 
 When `./gradlew autogenerate` is invoke it invokes the code generatores in the following order
 1) All `autogenerateSource` Tasks referenced in Projects that are referenced by the `autogenerateDep` Task in autocode
 2) `autogenerateDerived`  is invoked next which creates F32 classes from F64 then _MT (concurrent) from labeled code
 
 The only place the `noauto` sourceSet is used is in `boofcv-types` and there is little reason for it to be
 used in any other sub-project. Auto generated code should be as decoupled as possible from regular code.
 An exception is made since auto generated code does reference image types to make refactoring easier make the code
 more maintainable. There was an attempt to get around this problem by auto generating
 the F32 for boofcv-types first before calling `autogenerateSource` but that failed since Gradle did not recognize
 the new code until the next time `autogenerate` was invoked.
 
 If anything weird is done in the Gradle build scripts for auto code generation it should reference this file and
 have an explanation added here. This is more of a comment for future developers than anything else.
 
# How to Generate _F32

Add a new directory to `Autocode64to32App`. Avoid adding new patterns as much as possible to that class. The more
cases you add the more chance of a conflict forming.

# How to Generate _MT

Add a new directory to `AutocodeConcurrentApp`. This requires special comment based annoications that are described
in the class level JavaDoc.

# Generating Everything Else

All other auto generated code must go in the sub-project's `src/generate/java` directory. The new class you write
that generates the code must extend `CodeGeneratorBase` and be placed in the package you wish the generated code
to appear it. To add you to the build process a Gradle task with the name `autogenerateSource` is placed
in that sub project's build.gradle file. Example: `boofcv-ip/build.gradle` you then need to add a reference to it
in `main/autocode/build.gradle`. If the future it's hoped that the script will automatically detect and invoke all
tasks with the name `autogenerateSource`.
